# 0X08 进程管理

## 进程

进程的准确定义其实现在还有争议.简单点说,一个程序执行一次就是一个进程(或者说电脑在做的一件事).

为了后续叙述方便我就说一下我自己对进程的理解(不一定对):

我们都知道计算机要执行一个任务,需要硬件与软件,算法和资源的配合.但是在硬件资源中,CPU和内存又占有特殊地位.一个程序运行的时候可以不需要打印机,不需要键盘输入,不需要显示器,但是不能没有CPU和内存.

为了合理规划任务执行,提高硬件利用率.就需要对CPU和内存的使用进行管理.这就引申出了操作系统的基本任务中的两个--内存管理和CPU管理.

进程就是在CPU管理和内存管理中提出的一个概念.一般来说,一个进程对应一个任务.把CPU工作时间,内存空间,其他硬件设备使用权等资源提供给它,它就能运作并完成我们的任务(如果进程中运行的程序代码没有问题的话).

但是,认为一个进程对应一个程序也是不妥的.因为我们所说的"任务"其实是一个模糊的概念.你可以把写完今天的英语作业看作一个任务.也可以把写完今天的数学作业看作一个任务.也可以把写完今天的所有作业看作一个任务.同样,一个进程中可以包含一个程序,也可以包含多个相关的程序.甚至可能是一个程序多次启动,产生多个进程--例如之前遇到过的在一个bash中启动另一个bash.

具体是那种情况,就看启动进程的代码怎么写了.实现具体程序的时候,选择单进程还是多进程,选择几个进程,这些问题一言难尽,不在这里做讨论.感兴趣可以去自行搜索一下相关内容.

## 进程树

就像我们做事一样,一个大任务看起来很困难.那就可以把大任务先分割成若干小任务去做.小任务如果还复杂,就分割成更小的任务.很多情况下为了及时性或者提高系统资源利用率等原因,把所有任务排个队,挨个完成的单进程模式并不是最好的选择.

当一个进程认为有必要把一部分任务分配给另一个进程的时候,就可以调用系统中特定的系统接口,会创建一个新的进程.被创建的那个新进程相对于原来的进程,叫做子进程.而创建新进程的进程叫做父进程.父子关系是相对的,很多进程一方面是一个进程的子进程,另一方面又是很多别的进程的父进程.

在进程管理的时候.如果一个进程没有子进程,那么它本身运行完就算完成了.但是如果一个进程有子进程没有运行完,我们就认为它本身没有运行完(因为子进程其实是分担了父进程的部分任务).因而,正常情况下,有子进程尚未终止的进程是不允许终止的.如果一定要终止,需要先对其子进程做处理(比如把要终止进程的子进程交给要终止的进程的父进程作为要终止的进程的父进程的子进程).

一般来说,能创建进程的只有另一个进程,除了一开机启动的那个初始进程.如果不考虑游离的进程的话,一个系统中所有的进程按照父子关系联结起来就构成一个树的形状.称为进程树.之后介绍的一些工具可以形象地展示出进程树.

## 实验准备

如果没有多个同时存在的进程,讨论进程管理就是没有意义的.但是到现在为止我们所介绍的大部分命令只需要很短的时间就能运行完.因此我们需要自己用脚本写一个不会自动终止的程序用于演示进程.下边是我用Lua写的一个死循环的程序.文件名为`loop.lua`.

```lua
while true do
end
```

## 后台运行

很多从bash启动的程序都是默认前台运行的.所谓前台运行就是说会占用终端.如果我们直接执行`loop.lua`,那么终端就会被它阻塞,无法输入别的命令.所以需要让它后台运行(仍然执行脚本中的命令,但是不占用键盘和显示器).

在输入命令时如果后接`&`则会后台运行.例如:

```shell
lua loop.lua &
```

## 





## 守护进程

toollib介绍systemd

介绍less

一个进程中包含所要执行的任务代码,以及执行任务所需要的资源(内存空间等).


    * 实现进程同步执行（或推进）有两种思路。区别在于对“同步”的理解不一致。

        + 如果两个进程齐头并进，对于每一个机器周期都是有两条分属于两个进程的指令在同时执行，就称为并行。实现这种“同步”，就需要硬件事实上有多个处理机。
        
        + 如果每一个机器周期只有一条指令在执行，但是在操作系统的控制下两个进程来回切换，一会推进这个进程一会推进另一个，整体上看两个进程推进的平均速度差不多，就属于并发。即使只有一个处理机，也能通过进程的切换实现并发。

    * 进程有三种基本状态：就绪，执行，阻塞。外加创造进程时的开始和完成进程后的结束，一共五种状态。而进程管理就是根据各个进程的执行状况和现在的资源情况让进程们在这几种状态之间来回切换。为了调度方便，一般还增加一种挂起状态（其实是两种状态——静止阻塞，静止就绪）。
    
3. 进程调度中的问题

    进程调度需要解决的主要是资源分配的问题。如果不把时间当成一种特殊资源的话，实时性也是一类特殊问题。这些问题是操作系统原理中的重头戏，但是由于我们不需要实现操作系统，所以这里只简要提一下死锁问题。

    * 死锁是资源分配中的问题。它是指虽然计算机整体资源足够，但是由于进程推进顺序不当等问题造成资源分配不合理，最终导致进程陷入僵局无法继续推进。

    * 举个最简单的例子：有两根筷子1号和2号（象征资源）。另有两个人A和B要吃饭（象征进程）。必须拿到全部筷子才能吃饭。例如A先拿到两根筷子，吃完再吧筷子给B，B也吃完。俩人的饭都吃完了。但是如果两个人各拿到一根筷子，还都不肯把自己的筷子给对方，这就会无限等下去，最后谁都吃不了饭。

    * 死锁问题的处理十分复杂。教科书上分为预防、避免、检测、解除四类问题。但是尽管有很多算法试图解决死锁问题，现实中死锁还是免不了时常出现。对于实在没有其他更好办法解决的死锁，最后的手段就是重启系统。


1. 内存状态查看

    没有直接的命令查看当前内存情况。Linux提供了一个文件用以映射当前内存实况。访问这个文件就能获得当前的内存信息。因此使用以下命令就能查看内存状态。

    >more /proc/meminfo

2. 目前的操作系统绝大多数都提供了并发性。要想查看当前Linux系统正在运行的进程信息，可以使用ps命令。其中的PID是系统内部用于识别不同进程的编号。

3. Linux中可以使用Ctrl+S挂起程序，用Ctrl+Q解除挂起。

4. 要想让当前在前台执行的程序暂停，返回命令行。则使用Ctrl+Z快捷键。如果要从命令行返回执行则使用fg命令。

5. 要想从命令行终止进程则使用kill命令加要终止的进程的PID。（前提是你拥有终止该进程的权限。）例如：

    >kill 1810

    但是有的程序有时会忽视这个请求。所以还需要加额外参数：

    >kill -s KILL 1810

    其中参数`-s`表示要向进程发送信息，`KILL`是要发送的信息，意在让进程立即终止。

6. 进程之间的通信是可以通过一种名为“管道”的方式。

    在shell中使用管道符`|`来表示管道。简单来说在这个符号后边的程序以前边程序的输出为输入。例如用less查看ls命令的输出：

    >ls | less

7.  重定性操作符可以完成和管道类似的功能。重定向操作符有`>`,`<`等。

    >ls > lsout.txt

    表示新建一个文件`lsout.txt`,并把ls命令执行结果保存进去。

    >cat < lsout.txt

    表示将`lsout.txt`作为cat命令的输入（cat命令本来是从标准输入读入一行然后在显示器上显示一行）。


# 02 进程管理工具
## 进程标识
1. 进程管理主要是查看、终止、挂起和继续进程。本期主要介绍bash内置的进程管理命令。
2. 进程在操作系统中由PID（Process ID）标识。
3. 在使用bash的进程管理时，还会给每个可以管理的进程分配一个工作号（job number）。
4. 使用jobs命令查看进程的信息。后加参数`-l`显示详细信息。例如：
    >```
    >[1]+  2630 Running                 xlogo &
    >```
    其中方括号内的1是工作号，2630是进程号。Running是执行状况。xlogo是进程名（xlogo是一个简单的用于显示一个小窗口的程序）。&符表示程序后台运行。
## 进程控制快捷键
1. 直观地理解，一个程序在前台运行就会用它的界面覆盖bash的命令行界面（例如正常启动的vim）。而后台运行的程序不会这样。但是注意后台运行的程序其实也可以通过调用输入输出流把文字输出到终端（例如后台运行的yes）。
2. 进程控制快捷键可以在无法向bash输入命令时控制进程。但是只对前台进程有效。另外这组快捷键并非由bash定义，而是由终端驱动解析，可以通过stty命令查看或修改（`stty -a`查看所有快捷键）。
    * C-z 暂停当前进程，并把控制权交还bash。
    * C-y 延迟暂停进程，当进程试图读取输入流时暂停进程并把控制权交还bash。
    * C-s 暂停当前进程，但不交还控制权给bash。
    * C-q 使用C-s暂停进程后使用C-q继续进程。
    * C-c 终止当前进程，返回bash。
3. 这些快捷键的本质是向当前前台进程发送信号。例如C-c发送SIGINT信号，C-z发送SIGTSTP信号。
## 信号机制
1. kill命令用于终止指定进程。例如`kill 2630`。一个比较常用的选项是`-9`，用于强制终止指定进程。例如`kill -9 2630`。
2. 指定进程有多种方法：
    * 之前例子中，kill后的2630是程序PID。
    * 也可以用工作号指定。但是工作号之前需要加百分号%。
    * `%+`和`%-`可以用于最近后台启动或暂停过的进程。具体指那个进程，可以通过jobs列表中工作号后的加减号辨别。
        + 带加号的被称为默认作业。带减号的是下一个默认作业。默认作业完成后下一个默认作业成为默认作业。
    * %后接进程名的部分拼写也可以指进程。这其中还可以用一些正则表达式规则。
3. 为了进一步说明kill命令先介绍一个suspend命令。如果执行这个命令的shell不是一开登录打开的shell，那么就会暂停当前shell。只有接收到SIGCONT信号时才会继续运行。
4. 严格来说kill命令不仅仅用于终止进程。它的完整功能是给指定进程传送信号。kill所支持的信号可以通过`kill -l`查看。可以做一个实验，打开两个虚拟终端，假设其中一个的bash的PID是2619（可以用ps、htop等工具查看）。在2619上运行suspend命令暂停bash。然后在另一个终端执行`kill -18 2619`就可以继续被暂停的bash。（SIGCONT对应数字18。）
## 其他进程调度操作
2. fg后接进程，将指定进程调至前台运行。
3. bg后接进程，将指定进程调指后台运行。
4. wait后接子进程。执行wait命令时bash将等待，当指定子进程结束后返回bash。
5. disown后接子进程。当bash退出时不会连带用disown指定的子进程一起退出。由于原有父进程终止，这个子进程将被挂到bash的父进程上。
6. 为以后介绍nohup做个铺垫。disown虽然和nohup看起来效果类似，但是对输入输出流的处理不一样。disown的进程默认情况下输出流仍然和Shell一致。而nohup一般会关闭进程输入流，并且把输出流定向到它指定的文件。


sed和awk贴上b站搬运的教程的出处地址
(grep和正则,那个视频中也有介绍)